<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Adobe XMP Toolkit: TXMPUtils&lt; tStringObj &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>TXMPUtils&lt; tStringObj &gt; Class Template Reference</h1><!-- doxytag: class="TXMPUtils" -->Template class for the XMP Toolkit utility services.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="TXMPUtils_8hpp-source.html">TXMPUtils.hpp</a>&gt;</code>
<p>
<a href="classTXMPUtils-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Path composition functions</div></td></tr>
<tr><td colspan="2"><div class="groupText">These functions provide support for composing path expressions to deeply nested properties. The functions in <code><a class="el" href="classTXMPMeta.html">TXMPMeta</a></code> such as <code>GetProperty</code>, <code>GetArrayItem</code>, and <code>GetStructField</code> provide easy access to top level simple properties, items in top level arrays, and fields of top level structs. They do not provide convenient access to more complex things like fields several levels deep in a complex struct, or fields within an array of structs, or items of an array that is a field of a struct. These functions can also be used to compose paths to top level array items or struct fields so that you can use the binary accessors like <code>GetProperty_Int</code>.<p>
You can use these functions is to compose a complete path expression, or all but the last component. Suppose you have a property that is an array of integers within a struct. You can access one of the array items like this:<p>
<div class="fragment"><pre class="fragment">
    ///  SXMPUtils::ComposeStructFieldPath ( schemaNS, "Struct", fieldNS, "Array", &amp;path );
    ///  SXMPUtils::ComposeArrayItemPath ( schemaNS, path, index, &amp;path );
    ///  exists = xmpObj.GetProperty_Int ( schemaNS, path, &amp;value, &amp;options );
    /// </pre></div><p>
You could also use this code if you want the string form of the integer:<p>
<div class="fragment"><pre class="fragment">
    ///  SXMPUtils::ComposeStructFieldPath ( schemaNS, "Struct", fieldNS, "Array", &amp;path );
    ///  xmpObj.GetArrayItem ( schemaNS, path, index, &amp;value, &amp;options );
    /// </pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It might look confusing that the <code>schemaNS</code> is passed in all of the calls above. This is because the XMP toolkit keeps the top level "schema" namespace separate from the rest of the path expression. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#47fa195aa2e1457aa1f74f7e1ed06da6">ComposeArrayItemPath</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> arrayName, <a class="el" href="XMP__Const_8h.html#00e9d9a76c144421105a4c2742203315">XMP_Index</a> itemIndex, tStringObj *fullPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compose the path expression for an item in an array.  <a href="#47fa195aa2e1457aa1f74f7e1ed06da6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#706eb85b8401b8682a01348f7e25ee3d">ComposeStructFieldPath</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> structName, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> fieldNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> fieldName, tStringObj *fullPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compose the path expression for a field in a struct.  <a href="#706eb85b8401b8682a01348f7e25ee3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#40ae0ce2065fcb71725e37137884e172">ComposeQualifierPath</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> propName, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> qualNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> qualName, tStringObj *fullPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compose the path expression for a qualifier.  <a href="#40ae0ce2065fcb71725e37137884e172"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#e4989e5c199a2a4287ee3ae89b872e69">ComposeLangSelector</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> arrayName, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> langName, tStringObj *fullPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compose the path expression to select an alternate item by language.  <a href="#e4989e5c199a2a4287ee3ae89b872e69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7882bbc2e412ff476c2d97d98808d91c"></a><!-- doxytag: member="TXMPUtils::ComposeLangSelector" ref="7882bbc2e412ff476c2d97d98808d91c" args="(XMP_StringPtr schemaNS, XMP_StringPtr arrayName, const tStringObj &amp;langName, tStringObj *fullPath)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#7882bbc2e412ff476c2d97d98808d91c">ComposeLangSelector</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> arrayName, const tStringObj &amp;langName, tStringObj *fullPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of <code>ComposeLangSelector</code> is a simple overload in the template that calls the above form passing <code>langName.c_str()</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#458f8e8729e2334fe54ca8f691a9db23">ComposeFieldSelector</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> arrayName, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> fieldNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> fieldName, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> fieldValue, tStringObj *fullPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compose the path expression to select an alternate item by a field's value.  <a href="#458f8e8729e2334fe54ca8f691a9db23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2d2361b8a4d0709ec9e3bd837265cba"></a><!-- doxytag: member="TXMPUtils::ComposeFieldSelector" ref="d2d2361b8a4d0709ec9e3bd837265cba" args="(XMP_StringPtr schemaNS, XMP_StringPtr arrayName, XMP_StringPtr fieldNS, XMP_StringPtr fieldName, const tStringObj &amp;fieldValue, tStringObj *fullPath)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#d2d2361b8a4d0709ec9e3bd837265cba">ComposeFieldSelector</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> arrayName, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> fieldNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> fieldName, const tStringObj &amp;fieldValue, tStringObj *fullPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of ComposeFieldSelector is a simple overload in the template that calls the above form passing <code>fieldValue.c_str()</code>. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Binary-String conversion functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#509691eb270988de6a770c9c8304ab6b">ConvertFromBool</a> (bool binValue, tStringObj *strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from Boolean to string.  <a href="#509691eb270988de6a770c9c8304ab6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#eec45b4d1a26717290105c9f4e8b4235">ConvertFromInt</a> (long binValue, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> format, tStringObj *strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from integer to string.  <a href="#eec45b4d1a26717290105c9f4e8b4235"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#e67ef3931836432b7e574832f0610ed0">ConvertFromFloat</a> (double binValue, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> format, tStringObj *strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from floating point to string.  <a href="#e67ef3931836432b7e574832f0610ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#6146a522a3974b4088d6e8241e9cd223">ConvertFromDate</a> (const <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> &amp;binValue, tStringObj *strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from date/time to string.  <a href="#6146a522a3974b4088d6e8241e9cd223"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#aaaaadb23f4089daa795f50cba4f405c">ConvertToBool</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from string to Boolean.  <a href="#aaaaadb23f4089daa795f50cba4f405c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84f2a7b3960a17315032915674e21960"></a><!-- doxytag: member="TXMPUtils::ConvertToBool" ref="84f2a7b3960a17315032915674e21960" args="(const tStringObj &amp;strValue)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#84f2a7b3960a17315032915674e21960">ConvertToBool</a> (const tStringObj &amp;strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of <code>ConvertToBool</code> is a simple overload in the template that calls the above form passing <code>strValue.c_str()</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#dfd9d1c522377d5db4ad667a7973ba00">ConvertToInt</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from string to integer.  <a href="#dfd9d1c522377d5db4ad667a7973ba00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47d93f9cb4acd9d7ec6b450100209bec"></a><!-- doxytag: member="TXMPUtils::ConvertToInt" ref="47d93f9cb4acd9d7ec6b450100209bec" args="(const tStringObj &amp;strValue)" -->
static long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#47d93f9cb4acd9d7ec6b450100209bec">ConvertToInt</a> (const tStringObj &amp;strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of <code>ConvertToInt</code> is a simple overload in the template that calls the above form passing <code>strValue.c_str()</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#be5d2dcc03c5442202203bba5ca7b172">ConvertToInt64</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from string to 64 bit integer.  <a href="#be5d2dcc03c5442202203bba5ca7b172"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="711cae0cb1b673ff5e208b4ae458d120"></a><!-- doxytag: member="TXMPUtils::ConvertToInt64" ref="711cae0cb1b673ff5e208b4ae458d120" args="(const tStringObj &amp;strValue)" -->
static long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#711cae0cb1b673ff5e208b4ae458d120">ConvertToInt64</a> (const tStringObj &amp;strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of ConvertToInt64 is a simple overload in the template that calls the above form passing <code>strValue.c_str()</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#8a507b006286460814e0486c622d828c">ConvertToFloat</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from string to floating point.  <a href="#8a507b006286460814e0486c622d828c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="abd4e479d2708a9ea3135cd441faa7ea"></a><!-- doxytag: member="TXMPUtils::ConvertToFloat" ref="abd4e479d2708a9ea3135cd441faa7ea" args="(const tStringObj &amp;strValue)" -->
static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#abd4e479d2708a9ea3135cd441faa7ea">ConvertToFloat</a> (const tStringObj &amp;strValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of <code>ConvertToFloat</code> is a simple overload in the template that calls the above form passing <code>strValue.c_str()</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#60d33e6ce30286028acca47b2b6e7a0b">ConvertToDate</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> strValue, <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *binValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from string to date/time.  <a href="#60d33e6ce30286028acca47b2b6e7a0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="265559d1b4b78e34a460e935c11177d7"></a><!-- doxytag: member="TXMPUtils::ConvertToDate" ref="265559d1b4b78e34a460e935c11177d7" args="(const tStringObj &amp;strValue, XMP_DateTime *binValue)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#265559d1b4b78e34a460e935c11177d7">ConvertToDate</a> (const tStringObj &amp;strValue, <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *binValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of <code>ConvertToDate</code> is a simple overload in the template that calls the above form passing s<code>strValue.c_str()</code>. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Date/Time functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#c83f0b963ea64d7eee0b481e15a8439c">CurrentDateTime</a> (<a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the current date and time.  <a href="#c83f0b963ea64d7eee0b481e15a8439c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#96bcc45febac55f6c49951815b7de2ef">SetTimeZone</a> (<a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local time zone.  <a href="#96bcc45febac55f6c49951815b7de2ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#bbd4d691c83287ea2fc6b1e33e5858b8">ConvertToUTCTime</a> (<a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure a time is UTC.  <a href="#bbd4d691c83287ea2fc6b1e33e5858b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#61852aaba494c8fbad5a6c0c4caf21f5">ConvertToLocalTime</a> (<a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure a time is local.  <a href="#61852aaba494c8fbad5a6c0c4caf21f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#9fc7f1771032f59f9020aeda4f91991d">CompareDateTime</a> (const <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> &amp;left, const <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> &amp;right)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the order of two date/time values.  <a href="#9fc7f1771032f59f9020aeda4f91991d"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Base 64 Encoding and Decoding</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#ef3b23bbc152480f699e269620ecad4a">EncodeToBase64</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> rawStr, <a class="el" href="XMP__Const_8h.html#9f7dcc184f901c713274edfdac5bcc9a">XMP_StringLen</a> rawLen, tStringObj *encodedStr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from raw data to Base64 encoded string.  <a href="#ef3b23bbc152480f699e269620ecad4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="39d5de77b29441a30f2f879755b8e7d8"></a><!-- doxytag: member="TXMPUtils::EncodeToBase64" ref="39d5de77b29441a30f2f879755b8e7d8" args="(const tStringObj &amp;rawStr, tStringObj *encodedStr)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#39d5de77b29441a30f2f879755b8e7d8">EncodeToBase64</a> (const tStringObj &amp;rawStr, tStringObj *encodedStr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of <code>EncodeToBase64</code> is a simple overload in the template that calls the above form passing <code>rawStr.c_str()</code>, and <code>rawStr.size()</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#e5bdd91c0c3ee9262dc0a8b9f591b921">DecodeFromBase64</a> (<a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> encodedStr, <a class="el" href="XMP__Const_8h.html#9f7dcc184f901c713274edfdac5bcc9a">XMP_StringLen</a> encodedLen, tStringObj *rawStr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode from Base64 encoded string to raw data.  <a href="#e5bdd91c0c3ee9262dc0a8b9f591b921"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e61e273065b10517ca127d5a553a8dc"></a><!-- doxytag: member="TXMPUtils::DecodeFromBase64" ref="1e61e273065b10517ca127d5a553a8dc" args="(const tStringObj &amp;encodedStr, tStringObj *rawStr)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#1e61e273065b10517ca127d5a553a8dc">DecodeFromBase64</a> (const tStringObj &amp;encodedStr, tStringObj *rawStr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of <code>DecodeFromBase64</code> is a simple overload in the template that calls the above form passing <code>encodedStr.c_str()</code>, and <code>encodedStr.size()</code>. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">JPEG file handling</div></td></tr>
<tr><td colspan="2"><div class="groupText">These functions support the partitioning of XMP in JPEG files into standard and extended portions in order to work around the 64KB size limit of JPEG marker segments. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#6001b4ff54c60fdf0c40e6b78a5c457a">PackageForJPEG</a> (const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;xmpObj, tStringObj *standardXMP, tStringObj *extendedXMP, tStringObj *extendedDigest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create XMP serializations appropriate for a JPEG file. The standard XMP in a JPEG file is limited to about 65500 bytes. <code>PackageForJPEG</code> attempts to fit the serialization within that limit. If necessary it will partition the XMP into 2 serializations.  <a href="#6001b4ff54c60fdf0c40e6b78a5c457a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#6187cd5fef0eccecac6805d4114dcd2e">MergeFromJPEG</a> (<a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *fullXMP, const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;extendedXMP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put the extended XMP properties back into the full XMP.  <a href="#6187cd5fef0eccecac6805d4114dcd2e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">UI helper functions</div></td></tr>
<tr><td colspan="2"><div class="groupText">These functions are mainly of interest in implementing a user interface for editing XMP. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#d7e1aa7928252fb88a24fb5c3aef22ba">CatenateArrayItems</a> (const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;xmpObj, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> arrayName, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> separator, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> quotes, <a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a> options, tStringObj *catedStr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a single edit string from an array of strings.  <a href="#d7e1aa7928252fb88a24fb5c3aef22ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#66c5ddee47aa36ed906353f94ca18d2e">SeparateArrayItems</a> (<a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *xmpObj, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> arrayName, <a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a> options, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> catedStr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Separate a single edit string into an array of strings.  <a href="#66c5ddee47aa36ed906353f94ca18d2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1bb2ed614886ff67863744ec56041c43"></a><!-- doxytag: member="TXMPUtils::SeparateArrayItems" ref="1bb2ed614886ff67863744ec56041c43" args="(TXMPMeta&lt; tStringObj &gt; *xmpObj, XMP_StringPtr schemaNS, XMP_StringPtr arrayName, XMP_OptionBits options, const tStringObj &amp;catedStr)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#1bb2ed614886ff67863744ec56041c43">SeparateArrayItems</a> (<a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *xmpObj, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> arrayName, <a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a> options, const tStringObj &amp;catedStr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This form of <code>SeparateArrayItems</code> is a simple overload in the template that calls the aboveform passing <code>catedStr.c_str()</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#40c645803530662e08d042b4b7c6190d">RemoveProperties</a> (<a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *xmpObj, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> schemaNS=0, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> propName=0, <a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a> options=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove multiple properties from an XMP object.  <a href="#40c645803530662e08d042b4b7c6190d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#4795244ffcbda927800f789b0e40c262">AppendProperties</a> (const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;source, <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *dest, <a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a> options=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append properties from one XMP object to another.  <a href="#4795244ffcbda927800f789b0e40c262"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTXMPUtils.html#a17838f062e5414bc0929f67ac94a3aa">DuplicateSubtree</a> (const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;source, <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *dest, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> sourceNS, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> sourceRoot, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> destNS=0, <a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a> destRoot=0, <a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a> options=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replicate a subtree from one XMP object into another, possibly at a different location.  <a href="#a17838f062e5414bc0929f67ac94a3aa"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class tStringObj&gt;<br>
 class TXMPUtils&lt; tStringObj &gt;</h3>

Template class for the XMP Toolkit utility services. 
<p>
<code><a class="el" href="classTXMPUtils.html">TXMPUtils</a></code> is the template class providing utility services for the XMP Toolkit. It should be instantiated with a string class such as <code>std::string</code>. Please read the general toolkit usage notes for information about the overall architecture of the XMP API.<p>
This is a class for C++ scoping purposes only. It has only static functions, you cannot create an object. These are all functions that layer cleanly on top of the core XMP toolkit. The template wraps a string class around the raw XMP API, so that output strings are automatically copied and access is fully thread safe. String objects are only necessary for output strings. Input strings are literals and passed as typical C <code>const char *</code>.<p>
The template parameter, class <code>TtStringObj</code>, is described in the XMP.hpp umbrella header. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="47fa195aa2e1457aa1f74f7e1ed06da6"></a><!-- doxytag: member="TXMPUtils::ComposeArrayItemPath" ref="47fa195aa2e1457aa1f74f7e1ed06da6" args="(XMP_StringPtr schemaNS, XMP_StringPtr arrayName, XMP_Index itemIndex, tStringObj *fullPath)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ComposeArrayItemPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>schemaNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>arrayName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#00e9d9a76c144421105a4c2742203315">XMP_Index</a>&nbsp;</td>
          <td class="paramname"> <em>itemIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>fullPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compose the path expression for an item in an array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>schemaNS</em>&nbsp;</td><td>The namespace URI for the array. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arrayName</em>&nbsp;</td><td>The name of the array. May be a general path expression, must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itemIndex</em>&nbsp;</td><td>The index of the desired item. Arrays in XMP are indexed from 1. The constant <code>kXMP_ArrayLastItem</code> always refers to the last existing array item.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fullPath</em>&nbsp;</td><td>A pointer to the string that will be assigned the composed path. This will be of the form <code>ns:arrayName[i]</code>, where "ns" is the prefix for <code>schemaNS</code> and "i" is the decimal representation of <code>itemIndex</code>. If the value of <code>itemIndex</code> is <code>kXMP_ArrayLastItem</code>, the path is <code>ns:arrayName[last()]</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="706eb85b8401b8682a01348f7e25ee3d"></a><!-- doxytag: member="TXMPUtils::ComposeStructFieldPath" ref="706eb85b8401b8682a01348f7e25ee3d" args="(XMP_StringPtr schemaNS, XMP_StringPtr structName, XMP_StringPtr fieldNS, XMP_StringPtr fieldName, tStringObj *fullPath)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ComposeStructFieldPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>schemaNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>structName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>fieldNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>fullPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compose the path expression for a field in a struct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>schemaNS</em>&nbsp;</td><td>The namespace URI for the struct. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>structName</em>&nbsp;</td><td>The name of the struct. May be a general path expression, must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fieldNS</em>&nbsp;</td><td>The namespace URI for the field. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>The name of the field. Must be a simple XML name, must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fullPath</em>&nbsp;</td><td>A pointer to the string that will be assigned the composed path. This will be of the form <code>ns:structName/fNS:fieldName</code>, where "ns" is the prefix for <code>schemaNS</code> and "fNS" is the prefix for <code>fieldNS</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40ae0ce2065fcb71725e37137884e172"></a><!-- doxytag: member="TXMPUtils::ComposeQualifierPath" ref="40ae0ce2065fcb71725e37137884e172" args="(XMP_StringPtr schemaNS, XMP_StringPtr propName, XMP_StringPtr qualNS, XMP_StringPtr qualName, tStringObj *fullPath)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ComposeQualifierPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>schemaNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>propName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>qualNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>qualName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>fullPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compose the path expression for a qualifier. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>schemaNS</em>&nbsp;</td><td>The namespace URI for the property to which the qualifier is attached. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>propName</em>&nbsp;</td><td>The name of the property to which the qualifier is attached. May be a general path expression, must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qualNS</em>&nbsp;</td><td>The namespace URI for the qualifier. May be null or the empty string if the qualifier is in the XML empty namespace.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qualName</em>&nbsp;</td><td>The name of the qualifier. Must be a simple XML name, must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fullPath</em>&nbsp;</td><td>A pointer to the string that will be assigned the composed path. This will be of the form <code>ns:propName/?qNS:qualName</code>, where "ns" is the prefix for <code>schemaNS</code> and "qNS" is the prefix for <code>qualNS</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e4989e5c199a2a4287ee3ae89b872e69"></a><!-- doxytag: member="TXMPUtils::ComposeLangSelector" ref="e4989e5c199a2a4287ee3ae89b872e69" args="(XMP_StringPtr schemaNS, XMP_StringPtr arrayName, XMP_StringPtr langName, tStringObj *fullPath)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ComposeLangSelector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>schemaNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>arrayName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>langName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>fullPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compose the path expression to select an alternate item by language. 
<p>
The path syntax allows two forms of "content addressing" that may be used to select an item in an array of alternatives. The form used in <code>ComposeLangSelector</code> lets you select an item in an alt-text array based on the value of its <code>xml:lang</code> qualifier. The other form of content addressing is shown in <code>ComposeFieldSelector</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><code>ComposeLangSelector</code> does not supplant <code>SetLocalizedText</code> or <code>GetLocalizedText</code>. They should generally be used, as they provide extra logic to choose the appropriate language and maintain consistency with the 'x-default' value. <code>ComposeLangSelector</code> gives you an path expression that is explicitly and only for the language given in the <code>langName</code> parameter.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>schemaNS</em>&nbsp;</td><td>The namespace URI for the array. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arrayName</em>&nbsp;</td><td>The name of the array. May be a general path expression, must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>langName</em>&nbsp;</td><td>The RFC 3066 code for the desired language.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fullPath</em>&nbsp;</td><td>A pointer to the string that will be assigned the composed path. This will be of the form <code>ns:arrayName[@xml:lang='langName']</code>, where "ns" is the prefix for <code>schemaNS</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="458f8e8729e2334fe54ca8f691a9db23"></a><!-- doxytag: member="TXMPUtils::ComposeFieldSelector" ref="458f8e8729e2334fe54ca8f691a9db23" args="(XMP_StringPtr schemaNS, XMP_StringPtr arrayName, XMP_StringPtr fieldNS, XMP_StringPtr fieldName, XMP_StringPtr fieldValue, tStringObj *fullPath)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ComposeFieldSelector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>schemaNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>arrayName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>fieldNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>fieldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>fullPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compose the path expression to select an alternate item by a field's value. 
<p>
The path syntax allows two forms of "content addressing" that may be used to select an item in an array of alternatives. The form used in <code>ComposeFieldSelector</code> lets you select an item in an array of structs based on the value of one of the fields in the structs. The other form of content addressing is shown in <code>ComposeLangSelector</code>.<p>
For example, consider a simple struct that has two fields, the name of a city and the URI of an FTP site in that city. Use this to create an array of download alternatives. You can show the user a popup built from the values of the city fields. You can then get the corresponding URI as follows:<p>
<div class="fragment"><pre class="fragment">
    ///  ComposeFieldSelector ( schemaNS, "Downloads", fieldNS, "City", chosenCity, &amp;path );
    ///  exists = GetStructField ( schemaNS, path, fieldNS, "URI", &amp;uri );
    /// </pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>schemaNS</em>&nbsp;</td><td>The namespace URI for the array. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arrayName</em>&nbsp;</td><td>The name of the array. May be a general path expression, must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fieldNS</em>&nbsp;</td><td>The namespace URI for the field used as the selector. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>The name of the field used as the selector. Must be a simple XML name, must not be null or the empty string. It must be the name of a field that is itself simple.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fieldValue</em>&nbsp;</td><td>The desired value of the field.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fullPath</em>&nbsp;</td><td>A pointer to the string that will be assigned the composed path. This will be of the form <code>ns:arrayName[fNS:fieldName='fieldValue']</code>, where "ns" is the prefix for <code>schemaNS</code> and "fNS" is the prefix for <code>fieldNS</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="509691eb270988de6a770c9c8304ab6b"></a><!-- doxytag: member="TXMPUtils::ConvertFromBool" ref="509691eb270988de6a770c9c8304ab6b" args="(bool binValue, tStringObj *strValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertFromBool           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>binValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>strValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from Boolean to string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>binValue</em>&nbsp;</td><td>The Boolean value to be converted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The string representation of the Boolean. The values used are given by the macros <code>kXMP_TrueStr</code> and <code>kXMP_FalseStr</code> found in <code><a class="el" href="XMP__Const_8h.html">XMP_Const.h</a></code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="eec45b4d1a26717290105c9f4e8b4235"></a><!-- doxytag: member="TXMPUtils::ConvertFromInt" ref="eec45b4d1a26717290105c9f4e8b4235" args="(long binValue, XMP_StringPtr format, tStringObj *strValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertFromInt           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>binValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>strValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from integer to string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>binValue</em>&nbsp;</td><td>The integer value to be converted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>Optional C sprintf format for the conversion. Defaults to "%d".</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The string representation of the integer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e67ef3931836432b7e574832f0610ed0"></a><!-- doxytag: member="TXMPUtils::ConvertFromFloat" ref="e67ef3931836432b7e574832f0610ed0" args="(double binValue, XMP_StringPtr format, tStringObj *strValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertFromFloat           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>binValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>strValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from floating point to string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>binValue</em>&nbsp;</td><td>The floating point value to be converted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>Optional C sprintf format for the conversion. Defaults to "%f".</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The string representation of the floating point value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6146a522a3974b4088d6e8241e9cd223"></a><!-- doxytag: member="TXMPUtils::ConvertFromDate" ref="6146a522a3974b4088d6e8241e9cd223" args="(const XMP_DateTime &amp;binValue, tStringObj *strValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertFromDate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>binValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>strValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from date/time to string. 
<p>
Format a date according to the ISO 8601 profile in <a href="http://www.w3.org/TR/NOTE-datetime:">http://www.w3.org/TR/NOTE-datetime:</a> YYYY YYYY-MM YYYY-MM-DD YYYY-MM-DDThh:mmTZD YYYY-MM-DDThh:mm:ssTZD YYYY-MM-DDThh:mm:ss.sTZD<p>
YYYY = four-digit year MM = two-digit month (01=January, etc.) DD = two-digit day of month (01 through 31) hh = two digits of hour (00 through 23) mm = two digits of minute (00 through 59) ss = two digits of second (00 through 59) s = one or more digits representing a decimal fraction of a second TZD = time zone designator (Z or +hh:mm or -hh:mm)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>ISO 8601 does not seem to allow years less than 1000 or greater than 9999. We allow any year, even negative ones. The year is formatted as "%.4d".<p>
As a compatibility "tactic" (OK, a hack), so-called time-only input is allowed where the year, month, and day are all zero. This is output as "0000-00-00...".</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>binValue</em>&nbsp;</td><td>The <code><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a></code> value to be converted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The ISO 8601 string representation of the date/time. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="aaaaadb23f4089daa795f50cba4f405c"></a><!-- doxytag: member="TXMPUtils::ConvertToBool" ref="aaaaadb23f4089daa795f50cba4f405c" args="(XMP_StringPtr strValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertToBool           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>strValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from string to Boolean. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The string representation of the Boolean.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The appropriate C++ bool value for the string. The preferred strings are <code>kXMP_TrueStr</code> and <code>kXMP_FalseStr</code>. If these do not match, a case insensitive comparison is tried, then simply 't' or 'f', and finally non-zero and zero integer representations. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dfd9d1c522377d5db4ad667a7973ba00"></a><!-- doxytag: member="TXMPUtils::ConvertToInt" ref="dfd9d1c522377d5db4ad667a7973ba00" args="(XMP_StringPtr strValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static long <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertToInt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>strValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from string to integer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The string representation of the integer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The integer value as a C long. </dd></dl>

</div>
</div><p>
<a class="anchor" name="be5d2dcc03c5442202203bba5ca7b172"></a><!-- doxytag: member="TXMPUtils::ConvertToInt64" ref="be5d2dcc03c5442202203bba5ca7b172" args="(XMP_StringPtr strValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static long long <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertToInt64           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>strValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from string to 64 bit integer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The string representation of the integer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The integer value as a C long long. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a507b006286460814e0486c622d828c"></a><!-- doxytag: member="TXMPUtils::ConvertToFloat" ref="8a507b006286460814e0486c622d828c" args="(XMP_StringPtr strValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertToFloat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>strValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from string to floating point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The string representation of the floating point value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The floating point value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="60d33e6ce30286028acca47b2b6e7a0b"></a><!-- doxytag: member="TXMPUtils::ConvertToDate" ref="60d33e6ce30286028acca47b2b6e7a0b" args="(XMP_StringPtr strValue, XMP_DateTime *binValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertToDate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>strValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *&nbsp;</td>
          <td class="paramname"> <em>binValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from string to date/time. 
<p>
Parse a date according to the ISO 8601 profile in <a href="http://www.w3.org/TR/NOTE-datetime:">http://www.w3.org/TR/NOTE-datetime:</a> YYYY YYYY-MM YYYY-MM-DD YYYY-MM-DDThh:mmTZD YYYY-MM-DDThh:mm:ssTZD YYYY-MM-DDThh:mm:ss.sTZD<p>
YYYY = four-digit year MM = two-digit month (01=January, etc.) DD = two-digit day of month (01 through 31) hh = two digits of hour (00 through 23) mm = two digits of minute (00 through 59) ss = two digits of second (00 through 59) s = one or more digits representing a decimal fraction of a second TZD = time zone designator (Z or +hh:mm or -hh:mm)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>ISO 8601 does not seem to allow years less than 1000 or greater than 9999. We allow any year, even negative ones. The year is assumed to be formatted as "%.4d".<p>
As compatibility "tactics" (OK, hacks), a missing date portion or missing TZD are tolerated. A missing date value may begin with "Thh:" or "hh:"; the year, month, and day are all set to zero in the <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> value. A missing TZD is assumed to be UTC.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strValue</em>&nbsp;</td><td>The ISO 8601 string representation of the date/time.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>binValue</em>&nbsp;</td><td>A pointer to the <code><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a></code> variable to be assigned the date/time components. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c83f0b963ea64d7eee0b481e15a8439c"></a><!-- doxytag: member="TXMPUtils::CurrentDateTime" ref="c83f0b963ea64d7eee0b481e15a8439c" args="(XMP_DateTime *time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::CurrentDateTime           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the current date and time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A pointer to the <code><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a></code> variable to be assigned the current date and time. The returned time is UTC, properly adjusted for the local time zone. The resolution of the time is not guaranteed to be finer than seconds. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="96bcc45febac55f6c49951815b7de2ef"></a><!-- doxytag: member="TXMPUtils::SetTimeZone" ref="96bcc45febac55f6c49951815b7de2ef" args="(XMP_DateTime *time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::SetTimeZone           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the local time zone. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A pointer to the <code><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a></code> variable containing the value to be modified. Any existing time zone value is replaced, the other date/time fields are not adjusted in any way. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bbd4d691c83287ea2fc6b1e33e5858b8"></a><!-- doxytag: member="TXMPUtils::ConvertToUTCTime" ref="bbd4d691c83287ea2fc6b1e33e5858b8" args="(XMP_DateTime *time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertToUTCTime           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure a time is UTC. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A pointer to the <code><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a></code> variable containing the time to be modified. If the time zone is not UTC, the time is adjusted and the time zone set to be UTC. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="61852aaba494c8fbad5a6c0c4caf21f5"></a><!-- doxytag: member="TXMPUtils::ConvertToLocalTime" ref="61852aaba494c8fbad5a6c0c4caf21f5" args="(XMP_DateTime *time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::ConvertToLocalTime           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure a time is local. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>A pointer to the <code><a class="el" href="structXMP__DateTime.html">XMP_DateTime</a></code> variable containing the time to be modified. If the time zone is not the local zone, the time is adjusted and the time zone set to be local. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9fc7f1771032f59f9020aeda4f91991d"></a><!-- doxytag: member="TXMPUtils::CompareDateTime" ref="9fc7f1771032f59f9020aeda4f91991d" args="(const XMP_DateTime &amp;left, const XMP_DateTime &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::CompareDateTime           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structXMP__DateTime.html">XMP_DateTime</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare the order of two date/time values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>The "lefthand" date/time.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right</em>&nbsp;</td><td>The "righthand" date/time.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>-1 if left is before right </li>
<li>0 if left matches right </li>
<li>+1 if left is after right </li>
</ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ef3b23bbc152480f699e269620ecad4a"></a><!-- doxytag: member="TXMPUtils::EncodeToBase64" ref="ef3b23bbc152480f699e269620ecad4a" args="(XMP_StringPtr rawStr, XMP_StringLen rawLen, tStringObj *encodedStr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::EncodeToBase64           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>rawStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#9f7dcc184f901c713274edfdac5bcc9a">XMP_StringLen</a>&nbsp;</td>
          <td class="paramname"> <em>rawLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>encodedStr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from raw data to Base64 encoded string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rawStr</em>&nbsp;</td><td>The pointer to raw data to be converted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rawLen</em>&nbsp;</td><td>The length of raw data to be converted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encodedStr</em>&nbsp;</td><td>The XMP object to contain the encoded string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e5bdd91c0c3ee9262dc0a8b9f591b921"></a><!-- doxytag: member="TXMPUtils::DecodeFromBase64" ref="e5bdd91c0c3ee9262dc0a8b9f591b921" args="(XMP_StringPtr encodedStr, XMP_StringLen encodedLen, tStringObj *rawStr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::DecodeFromBase64           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>encodedStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#9f7dcc184f901c713274edfdac5bcc9a">XMP_StringLen</a>&nbsp;</td>
          <td class="paramname"> <em>encodedLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>rawStr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode from Base64 encoded string to raw data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>encodedStr</em>&nbsp;</td><td>The pointer to encoded data to be converted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encodedLen</em>&nbsp;</td><td>The length of encoded datavto be converted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rawStr</em>&nbsp;</td><td>The XMP object to contain the decoded string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6001b4ff54c60fdf0c40e6b78a5c457a"></a><!-- doxytag: member="TXMPUtils::PackageForJPEG" ref="6001b4ff54c60fdf0c40e6b78a5c457a" args="(const TXMPMeta&lt; tStringObj &gt; &amp;xmpObj, tStringObj *standardXMP, tStringObj *extendedXMP, tStringObj *extendedDigest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::PackageForJPEG           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xmpObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>standardXMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>extendedXMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>extendedDigest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create XMP serializations appropriate for a JPEG file. The standard XMP in a JPEG file is limited to about 65500 bytes. <code>PackageForJPEG</code> attempts to fit the serialization within that limit. If necessary it will partition the XMP into 2 serializations. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xmpObj</em>&nbsp;</td><td>The XMP for the JPEG file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>standardXMP</em>&nbsp;</td><td>The full standard XMP packet.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extendedXMP</em>&nbsp;</td><td>The serialized extended XMP, empty if not needed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extendedDigest</em>&nbsp;</td><td>An MD5 digest of the serialized extended XMP, empty if not needed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6187cd5fef0eccecac6805d4114dcd2e"></a><!-- doxytag: member="TXMPUtils::MergeFromJPEG" ref="6187cd5fef0eccecac6805d4114dcd2e" args="(TXMPMeta&lt; tStringObj &gt; *fullXMP, const TXMPMeta&lt; tStringObj &gt; &amp;extendedXMP)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::MergeFromJPEG           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *&nbsp;</td>
          <td class="paramname"> <em>fullXMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>extendedXMP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put the extended XMP properties back into the full XMP. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fullXMP</em>&nbsp;</td><td>The full XMP, presumed to be initialized from the standard XMP packet.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extendedXMP</em>&nbsp;</td><td>The properties that were partitioned into the extended XMP. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d7e1aa7928252fb88a24fb5c3aef22ba"></a><!-- doxytag: member="TXMPUtils::CatenateArrayItems" ref="d7e1aa7928252fb88a24fb5c3aef22ba" args="(const TXMPMeta&lt; tStringObj &gt; &amp;xmpObj, XMP_StringPtr schemaNS, XMP_StringPtr arrayName, XMP_StringPtr separator, XMP_StringPtr quotes, XMP_OptionBits options, tStringObj *catedStr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::CatenateArrayItems           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xmpObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>schemaNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>arrayName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>quotes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a>&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tStringObj *&nbsp;</td>
          <td class="paramname"> <em>catedStr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a single edit string from an array of strings. 
<p>
TBD - needs more description<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xmpObj</em>&nbsp;</td><td>The XMP object containing the array to be catenated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>schemaNS</em>&nbsp;</td><td>The schema namespace URI for the array. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arrayName</em>&nbsp;</td><td>The name of the array. May be a general path expression, must not be null or the empty string. Each item in the array must be a simple string value.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>separator</em>&nbsp;</td><td>The string to be used to separate the items in the catenated string. Defaults to "; ", ASCII semicolon and space (U+003B, U+0020).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quotes</em>&nbsp;</td><td>The characters to be used as quotes around array items that contain a separator. Defaults to '"', ASCII quote (U+0022).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Option flags to control the catenation.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>catedStr</em>&nbsp;</td><td>A pointer to the string to be assigned the catenated array items. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="66c5ddee47aa36ed906353f94ca18d2e"></a><!-- doxytag: member="TXMPUtils::SeparateArrayItems" ref="66c5ddee47aa36ed906353f94ca18d2e" args="(TXMPMeta&lt; tStringObj &gt; *xmpObj, XMP_StringPtr schemaNS, XMP_StringPtr arrayName, XMP_OptionBits options, XMP_StringPtr catedStr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::SeparateArrayItems           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *&nbsp;</td>
          <td class="paramname"> <em>xmpObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>schemaNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>arrayName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a>&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>catedStr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Separate a single edit string into an array of strings. 
<p>
TBD - needs more description<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xmpObj</em>&nbsp;</td><td>The XMP object containing the array to be updated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>schemaNS</em>&nbsp;</td><td>The schema namespace URI for the array. Must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arrayName</em>&nbsp;</td><td>The name of the array. May be a general path expression, must not be null or the empty string. Each item in the array must be a simple string value.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Option flags to control the separation.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>catedStr</em>&nbsp;</td><td>The string to be separated into the array items. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40c645803530662e08d042b4b7c6190d"></a><!-- doxytag: member="TXMPUtils::RemoveProperties" ref="40c645803530662e08d042b4b7c6190d" args="(TXMPMeta&lt; tStringObj &gt; *xmpObj, XMP_StringPtr schemaNS=0, XMP_StringPtr propName=0, XMP_OptionBits options=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::RemoveProperties           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *&nbsp;</td>
          <td class="paramname"> <em>xmpObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>schemaNS</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>propName</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a>&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove multiple properties from an XMP object. 
<p>
<code>RemoveProperties</code> was created to support the File Info dialog's Delete button, and has been been generalized somewhat from those specific needs. It operates in one of three main modes depending on the schemaNS and propName parameters:<p>
<ul>
<li>Non-empty <code>schemaNS</code> and <code>propName</code> - The named property is removed if it is an external property, or if the <code>kXMPUtil_DoAllProperties</code> option is passed. It does not matter whether the named property is an actual property or an alias.</li>
</ul>
<ul>
<li>Non-empty <code>schemaNS</code> and empty <code>propName</code> - The all external properties in the named schema are removed. Internal properties are also removed if the <code>kXMPUtil_DoAllProperties</code> option is passed. In addition, aliases from the named schema will be removed if the <code>kXMPUtil_IncludeAliases</code> option is passed.</li>
</ul>
<ul>
<li>Empty <code>schemaNS</code> and empty <code>propName</code> - All external properties in all schema are removed. Internal properties are also removed if the <code>kXMPUtil_DoAllProperties</code> option is passed. Aliases are implicitly handled because the associated actuals are.</li>
</ul>
It is an error to pass and empty schemaNS and non-empty propName.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xmpObj</em>&nbsp;</td><td>The XMP object containing the properties to be removed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>schemaNS</em>&nbsp;</td><td>Optional schema namespace URI for the properties to be removed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>propName</em>&nbsp;</td><td>Optional path expression for the property to be removed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Option flags to control the deletion. The defined flags are: <ul>
<li><code>kXMPUtil_DoAllProperties</code> - Do internal properties in addition to external properties. </li>
<li><code>kXMPUtil_IncludeAliases</code> - Include aliases in the "named schema" case above. </li>
</ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4795244ffcbda927800f789b0e40c262"></a><!-- doxytag: member="TXMPUtils::AppendProperties" ref="4795244ffcbda927800f789b0e40c262" args="(const TXMPMeta&lt; tStringObj &gt; &amp;source, TXMPMeta&lt; tStringObj &gt; *dest, XMP_OptionBits options=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::AppendProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a>&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append properties from one XMP object to another. 
<p>
<code>AppendProperties</code> was created to support the File Info dialog's Append button, and has been been generalized somewhat from those specific needs. It appends information from one XMP object (<code>source</code>) to another (<code>dest</code>). The default operation is to append only external properties that do not already exist in the destination. The kXMPUtil_DoAllProperties option can be used to operate on all properties, external and internal. The kXMPUtil_ReplaceOldValues option can be used to replace the values of existing properties. The notion of external versus internal applies only to top level properties. The keep-or-replace-old notion applies within structs and arrays as described below.<p>
If kXMPUtil_ReplaceOldValues is passed then the processing is restricted to the top level properties. The processed properties from the source (according to kXMPUtil_DoAllProperties) are propagated to the destination, replacing any existing values. Properties in the destination that are not in the source are left alone.<p>
If kXMPUtil_ReplaceOldValues is not passed then the processing is more complicated. Top level properties are added to the destination if they do not already exist. If they do exist but differ in form (simple/struct/array) then the destination is left alone. If the forms match, simple properties are left unchanged while structs and arrays are merged.<p>
If kXMPUtil_DeleteEmptyValues is passed then an empty value in the source XMP causes the corresponding Dest XMP property to be deleted. The default is to treat empty values the same as non-empty values. An empty value is any of a simple empty string, an array with no items, or a struct with no fields. Qualifiers are ignored.<p>
The detailed behavior is defined by the following pseudo-code: <div class="fragment"><pre class="fragment">
    ///   AppendProperties ( sourceXMP, destXMP, options ):
    ///      doAll = options &amp; kXMPUtil_DoAllProperties
    ///      replaceOld = options &amp; kXMPUtil_ReplaceOldValues
    ///      deleteEmpty = options &amp; kXMPUtil_DeleteEmptyValues
    ///      for all source schema (top level namespaces):
    ///         for all top level properties in sourceSchema:
    ///            if doAll or prop is external:
    ///               AppendSubtree ( sourceNode, destSchema, replaceOld, deleteEmpty )
    ///
    ///   AppendSubtree ( sourceNode, destParent, replaceOld, deleteEmpty ):
    ///      if deleteEmpty and source value is empty:
    ///         delete the corresponding child from destParent
    ///      else if sourceNode not in destParent (by name):
    ///         copy sourceNode's subtree to destParent
    ///      else if replaceOld:
    ///         delete subtree from destParent
    ///         copy sourceNode's subtree to destParent
    ///      else:
    ///         // Already exists in dest and not replacing, merge structs and arrays
    ///         if sourceNode and destNode forms differ:
    ///            return, leave the destNode alone
    ///         else if form is a struct:
    ///            for each field in sourceNode:
    ///               AppendSubtree ( sourceNode.field, destNode, replaceOld )
    ///         else if form is an alt-text array:
    ///            copy new items by xml:lang value into the destination
    ///         else if form is an array:
    ///            copy new items by value into the destination, ignoring order and duplicates
    /// </pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><code>AppendProperties</code> can be expensive if replaceOld is not passed and the XMP contains large arrays. The array item checking described above is n-squared. Each source item is checked to see if it already exists in the destination, without regard to order or duplicates. Simple items are compared by value and xml:lang qualifier, other qualifiers are ignored. Structs are recursively compared by field names, without regard to field order. Arrays are compared by recursively comparing all items.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source XMP object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination XMP object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Option flags to control the copying. <ul>
<li><code>kXMPUtil_DoAllProperties</code> - Do internal properties in addition to external properties. </li>
<li><code>kXMPUtil_ReplaceOldValues</code> - Replace the values of existing properties. </li>
<li><code>kXMPUtil_DeleteEmptyValues</code> - Delete properties if the new value is empty. </li>
</ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a17838f062e5414bc0929f67ac94a3aa"></a><!-- doxytag: member="TXMPUtils::DuplicateSubtree" ref="a17838f062e5414bc0929f67ac94a3aa" args="(const TXMPMeta&lt; tStringObj &gt; &amp;source, TXMPMeta&lt; tStringObj &gt; *dest, XMP_StringPtr sourceNS, XMP_StringPtr sourceRoot, XMP_StringPtr destNS=0, XMP_StringPtr destRoot=0, XMP_OptionBits options=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tStringObj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTXMPUtils.html">TXMPUtils</a>&lt; tStringObj &gt;::DuplicateSubtree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTXMPMeta.html">TXMPMeta</a>&lt; tStringObj &gt; *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>sourceNS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>sourceRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>destNS</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#d439e3ceeb4590d310f6125aa12c6df6">XMP_StringPtr</a>&nbsp;</td>
          <td class="paramname"> <em>destRoot</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a>&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replicate a subtree from one XMP object into another, possibly at a different location. 
<p>
TBD - needs more description<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source XMP object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination XMP object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceNS</em>&nbsp;</td><td>The schema namespace URI for the source subtree.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceRoot</em>&nbsp;</td><td>The root location for the source subtree. May be a general path expression, must not be null or the empty string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destNS</em>&nbsp;</td><td>The schema namespace URI for the destination. Defaults to the source namespace.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destRoot</em>&nbsp;</td><td>The root location for the destination. May be a general path expression. Defaults to the source location.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Option flags to control the separation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="TXMPUtils_8hpp-source.html">TXMPUtils.hpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu May 3 14:54:59 2007 for Adobe XMP Toolkit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
