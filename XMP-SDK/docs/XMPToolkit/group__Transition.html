<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Adobe XMP Toolkit: XMP API Transition Guide</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>XMP API Transition Guide</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
This is a guide for XMP clients making the transition from the original C++ API to the revamped C++ API. The reader is assumed to be familiar with the old API, at least as far as used in the software being ported. The guide is presented as a series of old-to-new examples of typical usage. Reading the new API overview might provide background and motivation, but should not be necessary.<p>
The new API is totally different in detail, the names of all include files, functions, types, and constants have changed. Many of the changes though are fairly cosmetic and trivial to port. In most other cases the new API should be more convenient to use. The iteration/enumeration functions are the only ones with significant visible semantic change.<p>
This guide does not describe all of the old XMP functions, only those which have some non-trivial aspect for porting. If something is not described here, look at the old and new function signatures. They should be similar enough to make the transition obvious.<p>
This is particularly true for the old UtilityXAP functions, they all have obvious mappings. Some of the UtilityXAP functions have been moved to <a class="el" href="classTXMPMeta.html">TXMPMeta</a>, mainly the binary get/set functions (UtilityXAP::GetBoolean has become <a class="el" href="classTXMPMeta.html#dcf8a1959a8bd42641a42cbd4d64a5b7">TXMPMeta::GetProperty_Bool</a>). Low value functions like UtilityXAP::AnalyzeStep or UtilityXAP::FilterPropPath have been removed.<p>
<b>Classes</b><p>
The client API is defined by 3 C++ template classes: <a class="el" href="classTXMPMeta.html">TXMPMeta</a>, <a class="el" href="classTXMPIterator.html">TXMPIterator</a>, and <a class="el" href="classTXMPUtils.html">TXMPUtils</a>. These correspond to the old MetaXAP, XAPPaths, and UtilityXAP classes. The templates are instantiated with a string class which is used for the return of UTF-8 strings. The XMP headers will declare instantiated classes with the names SXMPMeta, SXMPIterator, and SXMPUtils.<p>
The associated string class must provide these member functions, identical to those of std::string: <div class="fragment"><pre class="fragment">    assign ( <span class="keyword">const</span> <span class="keywordtype">char</span> * str, size_t len )
    <span class="keyword">const</span> <span class="keywordtype">char</span> * c_str()
    size_t size()
</pre></div><p>
The result of assign does not matter, it is only used in a "void" manner.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>All of the code examples below assume the templates are instantiated using std::string.</dd></dl>
<b>Headers</b><p>
Clients should only include XMP.hpp to access XMP, and <a class="el" href="XMP_8incl__cpp.html">XMP.incl_cpp</a> to compile the template instantiations and client-side glue. The template string class is specified by defining TXMP_STRING_TYPE before the #include of either. A simple example is: <div class="fragment"><pre class="fragment"><span class="preprocessor">    #define TXMP_STRING_TYPE std::string</span>
<span class="preprocessor"></span><span class="preprocessor">    #include "XMP.hpp"</span>
<span class="preprocessor">    #include "<a class="code" href="XMP_8incl__cpp.html">XMP.incl_cpp</a>"</span>
</pre></div><p>
<b>Basic Property Access</b><p>
The old functions MetaXAP::get and MetaXAP::set are replaced by <a class="el" href="classTXMPMeta.html#06a3241c7fa5df87f61dff02fca23a0c">TXMPMeta::GetProperty</a> and <a class="el" href="classTXMPMeta.html#1dfd6a08ebfd1a6364b3a7b6584bcc28">TXMPMeta::SetProperty</a>. The basic mapping for these is very simple.<p>
The old way to set a simple property: <div class="fragment"><pre class="fragment">    meta.set ( XAP_NS_XAP, <span class="stringliteral">"CreatorTool"</span>, <span class="stringliteral">"Adobe Illustrator"</span> );
</pre></div><p>
The new way to set a simple property: <div class="fragment"><pre class="fragment">    meta.SetProperty ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"CreatorTool"</span>, <span class="stringliteral">"Adobe Illustrator"</span> );
</pre></div><p>
The old way to get a simple property: <div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span>        found;
    std::string value;
    XAPFeatures features;

    found = meta.get ( XAP_NS_XAP, <span class="stringliteral">"CreatorTool"</span>, value, features );
</pre></div><p>
The new way to get a simple property: <div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span>           found;
    std::string    value;
    <a class="code" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a> options;

    found = meta.GetProperty ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"CreatorTool"</span>, &amp;value, &amp;options );
</pre></div><p>
As before, you can pass XPath expressions for the second parameter to access elements of arrays or fields of structs. But there are new routines to make that easier. In addition, the new API allows you to eliminate the annoying '/*' for array items, reducing "Array/*[1]" to "Array[1]".<p>
The options parameter returns considerably more information than the old features parameter. See the enum constants in <a class="el" href="XMP__Const_8h.html">XMP_Const.h</a> for details.<p>
<b>Accessing Array Items</b><p>
There are now special get/set functions for array items that take the index as an integer. This relieves you of the burden of formatting a path expression with the index as a decimal string. The examples below for the first element generalizes to any index in the obvious ways.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The old get/set functions could only be used for existing array items. The new forms can be used to insert or append new items. See also the section on <b>Creating Array Items</b>.</dd></dl>
The old way to access the first element of an array: <div class="fragment"><pre class="fragment">    meta.set ( XAP_NS_XAP, <span class="stringliteral">"Authors/*[1]"</span>, <span class="stringliteral">"Frank Zappa"</span> );
    found = meta.get ( XAP_NS_XAP, <span class="stringliteral">"Authors/*[1]"</span>, value, features );
</pre></div><p>
The new way to access the first element of an array: <div class="fragment"><pre class="fragment">    meta.SetArrayItem ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"Authors"</span>, 1, <span class="stringliteral">"Frank Zappa"</span> );
    meta.GetArrayItem ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"Authors"</span>, 1, &amp;value, &amp;options );
</pre></div><p>
The old way to access the last element of an array: <div class="fragment"><pre class="fragment">    meta.set ( XAP_NS_XAP, <span class="stringliteral">"Authors/*[last()]"</span>, <span class="stringliteral">"Frank Zappa"</span> );
    found = meta.get ( XAP_NS_XAP, <span class="stringliteral">"Authors/*[last()]"</span>, value, features );
</pre></div><p>
The new way to access the last element of an array: <div class="fragment"><pre class="fragment">    meta.SetArrayItem ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"Authors"</span>, kXMP_ArrayLastItem, <span class="stringliteral">"Frank Zappa"</span> );
    meta.GetArrayItem ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"Authors"</span>, kXMP_ArrayLastItem, &amp;value, &amp;options );
</pre></div><p>
<b>Creating Array Items</b><p>
The old API had rather cumbersome createFirstItem and append functions to use when adding an item to an array. The new API has a more convenient AppendArrayItem function.<p>
The old way to create an array item, appending to the end: <div class="fragment"><pre class="fragment">    size_t count;

    <span class="keywordflow">try</span> {
        count = meta.count ( XAP_NS_XAP, <span class="stringliteral">"Authors/*"</span> );
    } <span class="keywordflow">catch</span> ( ... ) {
        count = 0
    }

    <span class="keywordflow">if</span> ( count == 0 ) {
        meta.createFirstItem ( XAP_NS_XAP, <span class="stringliteral">"Authors"</span>, <span class="stringliteral">"Frank Zappa"</span>, xap_seq );
    } <span class="keywordflow">else</span> {
        meta.append ( XAP_NS_XAP, <span class="stringliteral">"Authors/*[last()]"</span>, <span class="stringliteral">"Frank Zappa"</span> )
    }
</pre></div><p>
The new way to create an array item, appending to the end: <div class="fragment"><pre class="fragment">    meta.AppendArrayItem ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"Authors"</span>, kXMP_PropArrayIsOrdered, <span class="stringliteral">"Frank Zappa"</span> );
</pre></div><p>
Here's how to see if an array exists or how big it is: <div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span>    exists  = meta.DoesPropertyExist ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"Authors"</span> );
    size_t  count   = meta.CountArrayItems ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"Authors"</span> );
</pre></div> There are also DoesArrayItemExist and DoesStructFieldExist functions.<p>
<b>Accessing Struct Fields</b><p>
In the old API you accessed a field in a struct by writing an XPath expression of the general form "Struct/ns:Field". This has the subtle drawback that you must use the namespace prefix in the XPath expression. But prefixes are not guaranteed! The new API has functions that take the namespace URI.<p>
The old way to access a field in a struct: <div class="fragment"><pre class="fragment">    meta.set ( XAP_NS_XAP_T_PG, <span class="stringliteral">"MaxPageSize/stDim:unit"</span>, <span class="stringliteral">"inch"</span> );
    found = meta.get ( XAP_NS_XAP_T_PG, <span class="stringliteral">"MaxPageSize/stDim:unit"</span>, value, features );
</pre></div><p>
The new way to access a field in a struct: <div class="fragment"><pre class="fragment">    meta.SetStructField ( XAP_NS_XAP_T_PG, <span class="stringliteral">"MaxPageSize"</span>, kXMP_NS_ST_Dim, <span class="stringliteral">"unit"</span> <span class="stringliteral">"inch"</span> );
    found = meta.GetStructField ( XAP_NS_XAP_T_PG, <span class="stringliteral">"MaxPageSize"</span>, kXMP_NS_ST_Dim, <span class="stringliteral">"unit"</span>, &amp;value, &amp;options );
</pre></div><p>
<b>Accessing Composite Data Structures</b><p>
The old API forced you to write full XPath expressions for composite data structures with arrays or structs nested inside each other. This forced you to know the XPath syntax, and suffer the risks of using namespace prefixes for struct fields. The new API has path composition functions in XMPUtils to avoid both of these problems. You can compose the entire path then call Get/SetProperty, or compose all but the last portion then use Get/SetArrayItem or Get/SetStructField.<p>
The examples here only show ComposeArrayItemPath, ComposeStructFieldPath is an obvious analog.<p>
The old way to access a struct field within an array item: <div class="fragment"><pre class="fragment">    found = meta.get ( XAP_NS_XAP, <span class="stringliteral">"Thumbnails/*[1]/xapGImg:format"</span>, value, features );
</pre></div><p>
The new way to access a struct field within an array item: <div class="fragment"><pre class="fragment">    std::string itemPath;

    XMPUtils::ComposeArrayItemPath ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, <span class="stringliteral">"Thumbnails"</span>, 1, &amp;itemPath );
    found = meta.GetStructField ( <a class="code" href="XMP__Const_8h.html#030875c9dc0861c9251a3374ca14a376">kXMP_NS_XMP</a>, itemPath.c_str(),
                                  kXMP_NS_XMP_G_IMG, <span class="stringliteral">"format"</span>, &amp;value, &amp;options );
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>As in the old API, the outermost, or "schema", namespace is the first parameter to all functions that manipulate properties. Even if the second parameter is a complex path expression.</dd></dl>
<b>Parsing and Serializing</b><p>
The new API has the same construct-and-parse capability as the old API. This parses one buffer that must be a complete collection of XMP. Parsing multiple buffers where you do the I/O is similar to before, differing mainly in a reversal of the "I'm done" signal.<p>
The old way to read and parse: <div class="fragment"><pre class="fragment">    MetaXAP meta;
    <span class="keywordtype">char</span>    buffer [...];
    size_t  length;

    <span class="keywordflow">while</span> ( <span class="keyword">true</span> ) {
        -- read into buffer, setting length
        <span class="keywordflow">if</span> ( length != 0 ) <span class="keywordflow">break</span>;
        meta.parse ( buffer, length );
    }
    meta.parse ( buffer, 0, <span class="keyword">true</span> );
</pre></div><p>
The new way to read and parse: <div class="fragment"><pre class="fragment">    SXMPMeta    meta ( 0, 0 );
    <span class="keywordtype">char</span>    buffer [...];
    size_t  length;

    <span class="keywordflow">while</span> ( <span class="keyword">true</span> ) {
        -- read into buffer, setting length
        <span class="keywordflow">if</span> ( length != 0 ) <span class="keywordflow">break</span>;
        meta.ParseFromBuffer ( buffer, length, kXMP_ParseMoreBuffers );
    }
    meta.ParseFromBuffer ( buffer, 0 );
</pre></div><p>
Serialization in the old API was a multi-step process. You used MetaXAP::serialize to generate a hidden serialization, then used MetaXAP::extractSerialization to extract that, then used UtilityXAP::CreateXMLPacket to get the XMP packet wrapping. The New API combines all of this into <a class="el" href="classTXMPMeta.html#2774a6f15ae22f0002201b58c46bfb49">TXMPMeta::SerializeToBuffer</a>.<p>
The old way to write a serialized packet: <div class="fragment"><pre class="fragment">    size_t      rdfLength = meta.serialize();
    std::string header, trailer;
    <span class="keywordtype">char</span>        buffer [...];

    UtilityXAP::CreateXMLPacket ( <span class="stringliteral">""</span>, <span class="keyword">true</span>, 4096, <span class="stringliteral">"\n"</span>, header, trailer );
    -- write the header string
    <span class="keywordflow">while</span> ( rdfLength &gt; <span class="keyword">sizeof</span>(buffer) ) {
        meta.extractSerialization ( buffer, <span class="keyword">sizeof</span>(buffer) );
        -- write <span class="keyword">this</span> buffer
        rdfLength -= <span class="keyword">sizeof</span>(buffer);
    }
    meta.extractSerialization ( buffer, rdfLength );
    -- write <span class="keyword">this</span> buffer (only rdfLength bytes)
    -- write the trailer string
</pre></div><p>
The new way to write a serialized packet: <div class="fragment"><pre class="fragment">    std::string packet;

    meta.SerializeToBuffer ( &amp;packet );
    -- write the packet string
</pre></div><p>
<b>Iteration</b><p>
The functions to iterate over the XMP data tree have not changed a lot at first glance, but the way they operate has changed considerably.<p>
The old API essentially offered two ways to do an iteration: <ul>
<li>One call to generate a list of all leaf nodes </li>
<li>Program your own full traversal, recursively one level at a time</li>
</ul>
The new API performs a typical depth first traversal, visiting every node by default, with options to omit certain classes of nodes. Instead of mapping old patterns to new, it might make more sense to just use the new API and understand what it will return. It will also help to review the XMP data model, first documented in the November 2003 version of the XMP Specification. Pay attention to the option bits returned during iteration, they tell you what kind of node you're visiting.<p>
Simple, default iteration code in the new API: <div class="fragment"><pre class="fragment">    std::string     str1, str2, str3;
    <a class="code" href="XMP__Const_8h.html#eb865118433be92d88e5f49ed11487c8">XMP_OptionBits</a>  options;

    SXMPIterator iter ( meta );
    <span class="keywordflow">while</span> ( iter.Next ( &amp;str1, &amp;str2, &amp;str3, &amp;options ) ) {
        fprintf ( log, <span class="stringliteral">"  %s %s = \"%s\", 0x%X\n"</span>,
                  str1.c_str(), str2.c_str(), str3.c_str(), options );
    }
</pre></div><p>
For this RDF input: <div class="fragment"><pre class="fragment">    &lt;rdf:RDF xmlns:rdf='http:<span class="comment">//www.w3.org/1999/02/22-rdf-syntax-ns#'&gt;</span>
      &lt;rdf:Description rdf:about='' xmlns:ns1='ns:test1/' xmlns:ns2='ns:test2/'&gt;
    
        &lt;ns1:SimpleProp1&gt;Simple1 value&lt;/ns1:SimpleProp1&gt;
        &lt;ns1:SimpleProp2 xml:lang='x-<span class="keywordflow">default</span>'&gt;Simple2 value&lt;/ns1:SimpleProp2&gt;
    
        &lt;ns1:ArrayProp1&gt;
          &lt;rdf:Bag&gt;
            &lt;rdf:li&gt;Item1.1 value&lt;/rdf:li&gt;
            &lt;rdf:li&gt;Item1.2 value&lt;/rdf:li&gt;
          &lt;/rdf:Bag&gt;
        &lt;/ns1:ArrayProp1&gt;
    
        &lt;ns1:ArrayProp2&gt;
          &lt;rdf:Alt&gt;
            &lt;rdf:li xml:lang='x-one'&gt;Item2.1 value&lt;/rdf:li&gt;
            &lt;rdf:li xml:lang='x-two'&gt;Item2.2 value&lt;/rdf:li&gt;
          &lt;/rdf:Alt&gt;
        &lt;/ns1:ArrayProp2&gt;
    
        &lt;ns1:StructProp rdf:parseType='Resource'&gt;
          &lt;ns2:Field1&gt;Field1 value&lt;/ns2:Field1&gt;
          &lt;ns2:Field2&gt;Field2 value&lt;/ns2:Field2&gt;
        &lt;/ns1:StructProp&gt;
    
        &lt;ns1:QualProp1 rdf:parseType='Resource'&gt;
          &lt;rdf:value&gt;Prop value&lt;/rdf:value&gt;
          &lt;ns2:Qual&gt;Qual value&lt;/ns2:Qual&gt;
        &lt;/ns1:QualProp1&gt;
    
        &lt;ns1:QualProp2 rdf:parseType='Resource'&gt;
          &lt;rdf:value xml:lang='x-<span class="keywordflow">default</span>'&gt;Prop value&lt;/rdf:value&gt;
          &lt;ns2:Qual&gt;Qual value&lt;/ns2:Qual&gt;
        &lt;/ns1:QualProp2&gt;
    
        &lt;ns1:NestedStructProp rdf:parseType='Resource'&gt;
          &lt;ns2:Outer rdf:parseType='Resource'&gt;
            &lt;ns2:Middle rdf:parseType='Resource'&gt;
              &lt;ns2:Inner rdf:parseType='Resource'&gt;
                &lt;ns2:Field1&gt;Field1 value&lt;/ns2:Field1&gt;
                &lt;ns2:Field2&gt;Field2 value&lt;/ns2:Field2&gt;
              &lt;/ns2:Inner&gt;
            &lt;/ns2:Middle&gt;
          &lt;/ns2:Outer&gt;
        &lt;/ns1:NestedStructProp&gt;
    
      &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;
</pre></div><p>
The iteration shown above would print (spacing added by hand for legibility): <div class="fragment"><pre class="fragment">    ns:test1/  = <span class="stringliteral">""</span>, 0x80000000

    ns:test1/ SimpleProp1 = <span class="stringliteral">"Simple1 value"</span>, 0x0

    ns:test1/ SimpleProp2 = <span class="stringliteral">"Simple2 value"</span>, 0x50
    ns:test1/ SimpleProp2/?xml:lang = <span class="stringliteral">"x-default"</span>, 0x20

    ns:test1/ ArrayProp1 = <span class="stringliteral">""</span>, 0x200
    ns:test1/ ArrayProp1[1] = <span class="stringliteral">"Item1.1 value"</span>, 0x0
    ns:test1/ ArrayProp1[2] = <span class="stringliteral">"Item1.2 value"</span>, 0x0

    ns:test1/ ArrayProp2 = <span class="stringliteral">""</span>, 0xE00
    ns:test1/ ArrayProp2[1] = <span class="stringliteral">"Item2.1 value"</span>, 0x50
    ns:test1/ ArrayProp2[1]/?xml:lang = <span class="stringliteral">"x-one"</span>, 0x20
    ns:test1/ ArrayProp2[2] = <span class="stringliteral">"Item2.2 value"</span>, 0x50
    ns:test1/ ArrayProp2[2]/?xml:lang = <span class="stringliteral">"x-two"</span>, 0x20

    ns:test1/ StructProp = <span class="stringliteral">""</span>, 0x100
    ns:test1/ StructProp/ns2:Field1 = <span class="stringliteral">"Field1 value"</span>, 0x0
    ns:test1/ StructProp/ns2:Field2 = <span class="stringliteral">"Field2 value"</span>, 0x0

    ns:test1/ QualProp1 = <span class="stringliteral">"Prop value"</span>, 0x10
    ns:test1/ QualProp1/?ns2:Qual = <span class="stringliteral">"Qual value"</span>, 0x20

    ns:test1/ QualProp2 = <span class="stringliteral">"Prop value"</span>, 0x50
    ns:test1/ QualProp2/?xml:lang = <span class="stringliteral">"x-default"</span>, 0x20
    ns:test1/ QualProp2/?ns2:Qual = <span class="stringliteral">"Qual value"</span>, 0x20

    ns:test1/ NestedStructProp = <span class="stringliteral">""</span>, 0x100
    ns:test1/ NestedStructProp/ns2:Outer = <span class="stringliteral">""</span>, 0x100
    ns:test1/ NestedStructProp/ns2:Outer/ns2:Middle = <span class="stringliteral">""</span>, 0x100
    ns:test1/ NestedStructProp/ns2:Outer/ns2:Middle/ns2:Inner = <span class="stringliteral">""</span>, 0x100
    ns:test1/ NestedStructProp/ns2:Outer/ns2:Middle/ns2:Inner/ns2:Field1 = <span class="stringliteral">"Field1 value"</span>, 0x0
    ns:test1/ NestedStructProp/ns2:Outer/ns2:Middle/ns2:Inner/ns2:Field2 = <span class="stringliteral">"Field2 value"</span>, 0x0
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Thu May 3 14:54:58 2007 for Adobe XMP Toolkit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
